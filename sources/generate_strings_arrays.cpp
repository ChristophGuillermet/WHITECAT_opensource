        
int generate_help_file_engl()
{
//reset tableau
for(int l=0;l<1024;l++)
{
 sprintf(TblHelp[l][0],"");
 sprintf(TblHelp[l][1],"");
 sprintf(TblHelp[l][2],""); 
 btitle_help[l]=0;      
}    
    
int post=0;
int Hch_pos=0; int Hmem_pos=0; int Hpatch_pos=0; int Hvideo_pos=0; int Hhowfader_pos=0; int Hhowtrichro_pos=0; int Hhowvideo_pos=0;
int Hhowsequences_pos=0; int Hglobal_pos=0;
// TblHelp[1024][3][24];//1024 lignes / 3colonnes /48 caracteres
sprintf(TblHelp[post][0],"*** GLOBAL ACTIONS ***");
post++;
post++;
sprintf(TblHelp[post][1],"HELP : [SHIFT] [H]");
post++;
sprintf(TblHelp[post][0],"Quick Save");
sprintf(TblHelp[post][1],"[CTRL] [S]");
post++;
sprintf(TblHelp[post][0],"Quit and Save");
sprintf(TblHelp[post][1],"[CTRL] [F12]");
post++;
sprintf(TblHelp[post][0],"Quit and Don't Save");
sprintf(TblHelp[post][1],"[SHIFT] [F12]");
post++;
sprintf(TblHelp[post][0],"Snap and close windows");
sprintf(TblHelp[post][1],"[SHIFT] [PRINT SCREEN]");
post++;
sprintf(TblHelp[post][0],"Recall snapped windows");
sprintf(TblHelp[post][1],"[CTRL] [PRINT SCREEN]");
post++;
sprintf(TblHelp[post][0],"Store");
sprintf(TblHelp[post][1],"[F1]");
sprintf(TblHelp[post][2],"generally store the outputed channels");
post++;
sprintf(TblHelp[post][0],"Modify");
sprintf(TblHelp[post][1],"[F2]");
sprintf(TblHelp[post][2],"generally modify the selected channels");
post++;
sprintf(TblHelp[post][0],"Report");
sprintf(TblHelp[post][1],"[F3]");
sprintf(TblHelp[post][2],"Store the channels and contents of Faders");
post++;
sprintf(TblHelp[post][0],"Clear");
sprintf(TblHelp[post][1],"[F4]");
post++;
sprintf(TblHelp[post][0],"Name");
sprintf(TblHelp[post][1],"[F5]");
post++;
sprintf(TblHelp[post][0],"Time");
sprintf(TblHelp[post][1],"[F6]");
post++;
sprintf(TblHelp[post][0],"Trichromy");
sprintf(TblHelp[post][1],"[F7]");
post++;
sprintf(TblHelp[post][0],"Video Tracking");
sprintf(TblHelp[post][1],"[F8]");
post++;
sprintf(TblHelp[post][0],"Sequences");
sprintf(TblHelp[post][1],"[F9]");
post++;
sprintf(TblHelp[post][0],"Blind");
sprintf(TblHelp[post][1],"[Ctrl+F11]");
post++;
post++;
Hch_pos=post;
sprintf(TblHelp[post][0],"*** CHANNELS MANIPULATION ***");
post++;
post++;
sprintf(TblHelp[post][0],"* Channels selection");
post++;
sprintf(TblHelp[post][0],"Add to selection");
sprintf(TblHelp[post][1],"[+]");
sprintf(TblHelp[post][2],"[Num Ch] [+]");
post++;
sprintf(TblHelp[post][0],"Remove from selection");
sprintf(TblHelp[post][1],"[-]");
sprintf(TblHelp[post][2],"[Num Ch] [-]");
post++;
sprintf(TblHelp[post][0],"Thru Selection");
sprintf(TblHelp[post][1],"[TAB]");
sprintf(TblHelp[post][2],"[First Ch] [+] [Last Ch] [TAB]");
post++;
sprintf(TblHelp[post][0],"Select all lighting ch.");
sprintf(TblHelp[post][1],"[Y]");
post++;
sprintf(TblHelp[post][0],"Inverse selection");
sprintf(TblHelp[post][1],"[U]");
post++;
sprintf(TblHelp[post][0],"Clear selection");
sprintf(TblHelp[post][1],"[ESC]");
post++;
sprintf(TblHelp[post][0],"Select Previous");
sprintf(TblHelp[post][1],"[ARROW LEFT]");
post++;
sprintf(TblHelp[post][0],"Select Next");
sprintf(TblHelp[post][1],"[ARROW RIGHT]");
post++;
post++;
sprintf(TblHelp[post][0],"* Give a level to SELECTED channels");
post++;
sprintf(TblHelp[post][0],"At FULL");
sprintf(TblHelp[post][1],"[I]");
post++;
sprintf(TblHelp[post][0],"At ZERO");
sprintf(TblHelp[post][1],"[O]");
post++;
sprintf(TblHelp[post][0],"At a specific level");
sprintf(TblHelp[post][1],"[ENTER]");
sprintf(TblHelp[post][2],"[level] [ENTER]");
post++;
sprintf(TblHelp[post][0],"Plus default %");
sprintf(TblHelp[post][1],"[ARROW UP]");
post++;
sprintf(TblHelp[post][0],"Minus default %");
sprintf(TblHelp[post][1],"[ARROW DOWN]");
post++;
sprintf(TblHelp[post][0],"* Check Channel at Full");
post++;
sprintf(TblHelp[post][0],"Previous AT FULL");
sprintf(TblHelp[post][1],"[CTRL] [ARROW LEFT]");
post++;
sprintf(TblHelp[post][0],"Next AT FULL");
sprintf(TblHelp[post][1],"[CTRL] [ARROW RIGHT]");
post++;
post++;
post++;
Hmem_pos=post;
sprintf(TblHelp[post][0],"*** MEMORIES AND SEQUENCES [F9] ***");
post++;
sprintf(TblHelp[post][0],"* Recording / Deleting Memories");
post++;
sprintf(TblHelp[post][0],"Create or Over-record a Mem");
sprintf(TblHelp[post][1],"[SHIFT] [F1]");
sprintf(TblHelp[post][2],"[num. Mem] [SHIFT] [F1]");
post++;
sprintf(TblHelp[post][0],"Delete a Mem");
sprintf(TblHelp[post][1],"[SHIFT] [DEL]");
sprintf(TblHelp[post][2],"[num. Mem] [SHIFT] [DEL]");
post++;
sprintf(TblHelp[post][0],"Over-record Mem (stage/preset)");
sprintf(TblHelp[post][1],"[CTRL] [F1]");
post++;
sprintf(TblHelp[post][0],"Recall from Save a Mem");
sprintf(TblHelp[post][1],"[CTRL] [Z]");
post++;
sprintf(TblHelp[post][0],"Reload a deleted Mem");
sprintf(TblHelp[post][1],"[SHIFT] [Z]");
post++;
post++;
sprintf(TblHelp[post][0],"* Walking thruth Memories");
post++;
post++;
sprintf(TblHelp[post][0],"Previous Mem on Stage");
sprintf(TblHelp[post][1],"[CTRL] [W]");
post++;
sprintf(TblHelp[post][0],"Next Mem on Stage");
sprintf(TblHelp[post][1],"[CTRL] [W]");
post++;
sprintf(TblHelp[post][0],"Previous Mem on Preset");
sprintf(TblHelp[post][1],"[SHIFT] [X]");
post++;
sprintf(TblHelp[post][0],"Next Mem on Preset");
sprintf(TblHelp[post][1],"[SHIFT] [X]");
post++;
post++;
sprintf(TblHelp[post][0],"* Crossfade");
post++;
sprintf(TblHelp[post][0],"GO / PAUSE");
sprintf(TblHelp[post][1],"[SPACE]");
post++;
sprintf(TblHelp[post][0],"GO BACK");
sprintf(TblHelp[post][1],"[CTRL] [SPACE]");
post++;
sprintf(TblHelp[post][0],"DOUBLE GO");
sprintf(TblHelp[post][1],"[SHIFT] [SPACE]");
post++;
post++;
post++;
Hpatch_pos=post;
sprintf(TblHelp[post][0],"*** PATCH  ***");
sprintf(TblHelp[post][1],"[SHIFT] [P]");
post++;
post++;
sprintf(TblHelp[post][0],"* Dimmers selection");
post++;
sprintf(TblHelp[post][0],"Add to selection");
post++;
sprintf(TblHelp[post][1],"[SHIFT] [+]");
sprintf(TblHelp[post][2],"[Num Dim] [SHIFT] [+]");
post++;
sprintf(TblHelp[post][0],"Remove from selection");
sprintf(TblHelp[post][1],"[SHIFT] [-]");
sprintf(TblHelp[post][2],"[Num Dim] [SHIFT] [-]");
post++;
sprintf(TblHelp[post][0],"Thru Selection");
sprintf(TblHelp[post][1],"[SHIFT] [TAB]");
sprintf(TblHelp[post][2],"[First Dim][SHIFT][+] [Last Dim][SHIFT][TAB]");
post++;
sprintf(TblHelp[post][0],"Select all dimmers");
sprintf(TblHelp[post][1],"[SHIFT] [Y]");
post++;
sprintf(TblHelp[post][0],"Inverse patch selection");
sprintf(TblHelp[post][1],"[SHIFT] [U]");
post++;
sprintf(TblHelp[post][0],"Clear Patch selection");
sprintf(TblHelp[post][1],"[SHIFT] [ESC]");
post++;
sprintf(TblHelp[post][0],"* Affect dimmer selection to a  channel");
post++;
sprintf(TblHelp[post][0],"Affecting to last ch. selected");
sprintf(TblHelp[post][1],"[SHIFT] [ENTER]");
sprintf(TblHelp[post][2],"[Num ch][+][Num Dim][SHIFT][+][SHIFT][ENTER]");
post++;
sprintf(TblHelp[post][2],"                                         or ");
post++;
sprintf(TblHelp[post][2],"[Num Dim][SHIFT][+][Num ch][+][SHIFT][ENTER]");
post++;
sprintf(TblHelp[post][0],"Show dimmers controlled by a channel");
post++;
sprintf(TblHelp[post][0],"Channel selection [ARROW LEFT]/[ARROW RIGHT]");
post++;
post++;
post++;
Hvideo_pos=post;
sprintf(TblHelp[post][0],"*** VIDEO TRACKING ***");
sprintf(TblHelp[post][1],"[F8]");
post++;
sprintf(TblHelp[post][0],"Presets 1 to 6");
sprintf(TblHelp[post][1],"[W][X][C][V][B][N]");
post++;
sprintf(TblHelp[post][0],"ROI 1 to 6");
sprintf(TblHelp[post][1],"[A][Z][E][R][T][Y]");
post++;
sprintf(TblHelp[post][0],"ROI 7 to 12");
sprintf(TblHelp[post][1],"[Q][S][D][F][G][H]");
post++;
post++;
post++;
Hhowfader_pos=post;
sprintf(TblHelp[post][0],"*** QUICK HOW TO ***");
post++;
post++;
sprintf(TblHelp[post][0],"* FADERS AND DOCKS");
post++;
sprintf(TblHelp[post][0],"Affecting channels in a dock");
post++;
post++;
sprintf(TblHelp[post][2],"Light channels on stage or blind");
post++;
sprintf(TblHelp[post][2],"Press [F1] or click [STORE]");
post++;
sprintf(TblHelp[post][2],"Click the dock you want to store in");
post++;
sprintf(TblHelp[post][0],"Affecting a Memory in a dock");
post++;
sprintf(TblHelp[post][2],"Type the number of mem");
post++;
sprintf(TblHelp[post][2],"Press [F1] or click [STORE]");
post++;
sprintf(TblHelp[post][2],"Click the dock you want to store in");
post++;
sprintf(TblHelp[post][0],"Affecting a description to a dock");
post++;
sprintf(TblHelp[post][2],"Call [NAME] or press [F5], type your text");
post++;
sprintf(TblHelp[post][2],"Click the dock you want to store in");
post++;
sprintf(TblHelp[post][0],"Affecting time to a dock");
post++;
sprintf(TblHelp[post][2],"Call [TIME] or press [F4], choose which time");
post++;
sprintf(TblHelp[post][2],"Choose [IN] or [OUT]... and select [AFFECT]");
post++;
sprintf(TblHelp[post][2],"Click the dock you want to store in");
post++;
sprintf(TblHelp[post][0],"Affecting DMX IN to a dock");
post++;
sprintf(TblHelp[post][2],"Select [ART-NET>dock] or [DMX-IN>dock]");
post++;
sprintf(TblHelp[post][2],"Click the dock you want to affect");
post++;
sprintf(TblHelp[post][0],"Affecting a Trichromy Preset to a dock");
post++;
sprintf(TblHelp[post][2],"Select in Trichromy window the preset");
post++;
sprintf(TblHelp[post][2],"Click [AFFECT TO DOCK]");
post++;
sprintf(TblHelp[post][2],"Click the dock you want to affect");
post++;
sprintf(TblHelp[post][0],"Affecting VideoTracking output to a dock");
post++;
sprintf(TblHelp[post][2],"Click [AFFECT TO DOCK]");
post++;
sprintf(TblHelp[post][2],"Click the dock you want to affect");
post++;
sprintf(TblHelp[post][0],"Clear a dock");
post++;
sprintf(TblHelp[post][2],"Click [CLEAR] or type [F4]");
post++;
sprintf(TblHelp[post][2],"Click the dock you want to clear");
post++;
sprintf(TblHelp[post][0],"Clear completely a fader");
post++;
sprintf(TblHelp[post][2],"Click [CLEAR] or type [F4]");
post++;
sprintf(TblHelp[post][2],"Click the fader you want to clear");
post++;
sprintf(TblHelp[post][0],"View content of a dock");
post++;
sprintf(TblHelp[post][2],"Click [VIEW]");
post++;
sprintf(TblHelp[post][2],"Roll over with mouse over dock");
post++;
sprintf(TblHelp[post][0],"LOCK faders");
post++;
sprintf(TblHelp[post][2],"Click [LOCK]");
post++;
sprintf(TblHelp[post][2],"the level will be taken has lock level");
post++;
sprintf(TblHelp[post][2],"A Fader at Full on Lock becomes Master");
post++;
sprintf(TblHelp[post][0],"REPORT faders");
post++;
sprintf(TblHelp[post][2],"Click [REPORT]");
post++;
sprintf(TblHelp[post][2],"Click the Fader you want to report in");
post++;
sprintf(TblHelp[post][2],"All lighting Faders will be stored in it");
post++;
post++;
Hhowtrichro_pos=post;
sprintf(TblHelp[post][0],"* TRICHROMY");
post++;
post++;
sprintf(TblHelp[post][0],"Affecting channels to a color");
post++;
sprintf(TblHelp[post][2],"Select channels");
post++;
sprintf(TblHelp[post][2],"Press [F1] or click [STORE]");
post++;
sprintf(TblHelp[post][2],"Click the color you want to store in");
post++;
sprintf(TblHelp[post][0],"View content of a Color");
post++;
sprintf(TblHelp[post][2],"Click [VIEW]");
post++;
sprintf(TblHelp[post][2],"Roll over with mouse over color");
post++;
sprintf(TblHelp[post][0],"Affect a Trichromy Preset to a dock");
post++;
sprintf(TblHelp[post][2],"Click [AFFECT TO DOCK]");
post++;
sprintf(TblHelp[post][2],"Click the dock you want to affect");
post++;
post++;
Hhowvideo_pos=post;
sprintf(TblHelp[post][0],"* VIDEO TRACKING");
post++;
sprintf(TblHelp[post][0],"Affecting channels to a ROI");
post++;
sprintf(TblHelp[post][2],"Select channels");
post++;
sprintf(TblHelp[post][2],"Press [F1] or click [STORE]");
post++;
sprintf(TblHelp[post][2],"Click the ROI you want to store in");
post++;
sprintf(TblHelp[post][0],"View content of a ROI");
post++;
sprintf(TblHelp[post][2],"Click [VIEW]");
post++;
sprintf(TblHelp[post][2],"Roll over with mouse over ROI Pin");
post++;
sprintf(TblHelp[post][0],"Affect a Tracking Preset to a dock");
post++;
sprintf(TblHelp[post][2],"Click [AFFECT TO DOCK]");
post++;
sprintf(TblHelp[post][2],"Click the dock you want to affect");
post++;
post++;
Hhowsequences_pos=post;


sprintf(TblHelp[post][0],"* SEQUENCES WINDOW");
post++;
sprintf(TblHelp[post][0],"Creating a memory or over recording");
post++;
sprintf(TblHelp[post][2],"Light on stage or in blind");
post++;
sprintf(TblHelp[post][2],"Type num of mem and use Create mem");
post++;
sprintf(TblHelp[post][2],"                    or [SHIFT] [F1]");
post++;
sprintf(TblHelp[post][2],"Calling a memory");
post++;
sprintf(TblHelp[post][0],"Type num of mem");
post++;
sprintf(TblHelp[post][2],"Click mem stage or preset");
post++;
sprintf(TblHelp[post][2],"Works also on preset while crossfading");
post++;
sprintf(TblHelp[post][2],"Over-recording stage or preset");
post++;
sprintf(TblHelp[post][0],"Press [F1] or click [STORE]");
post++;
sprintf(TblHelp[post][2],"Click mem stage or preset");
post++;
sprintf(TblHelp[post][0],"or just type [CTRL][F1]");
post++;
sprintf(TblHelp[post][0],"Affect Time to stage or preset");
post++;
sprintf(TblHelp[post][2],"Use Time [F5] and click Affect");
post++;
sprintf(TblHelp[post][2],"Choose [IN] or [OUT]... and select [AFFECT]");
post++;
sprintf(TblHelp[post][2],"Click the Mem you want to store in");
post++;
sprintf(TblHelp[post][2],"OR ( only for onstage or preset memory ) ");
post++;
sprintf(TblHelp[post][2],"Type time: [ 5 ][ . ] is 5 seconds ");
post++;
sprintf(TblHelp[post][2],"[ 1 ][ . ][ . ] [ 1 ][ 0 ] [ . ] is 1 min 10 sec");
post++;
sprintf(TblHelp[post][2],"[ 4 ][ . ] [ 5 ] is 4 sec 5 1/10e");
post++;
sprintf(TblHelp[post][2],"Click the time pin to enter it");
post++;
sprintf(TblHelp[post][0],"Recording Output of Masters in a memory");
post++;
sprintf(TblHelp[post][2],"use [REPORT] [F3] in stead of [F1]");
post++;
sprintf(TblHelp[post][0],"Modifying selectively");
post++;
sprintf(TblHelp[post][2],"select channels, give new value");
post++;
sprintf(TblHelp[post][2],"use [MODIFY] [F2] in stead of [F1]");
post++;
sprintf(TblHelp[post][0],"Give a description to a mem");
post++;
sprintf(TblHelp[post][2],"click [NAME] or type [F5]");
post++;
sprintf(TblHelp[post][2],"type its name");
post++;
sprintf(TblHelp[post][2],"click description space of mem");
post++;
sprintf(TblHelp[post][0],"Linking memories");
post++;
sprintf(TblHelp[post][2],"[Link] must be activated");
post++;
sprintf(TblHelp[post][2],"Click Link colonn in front of the mem");
post++;
sprintf(TblHelp[post][0],"Setting a Banger in a memory");
post++;
sprintf(TblHelp[post][2],"[Banger] must be activated");
post++;
sprintf(TblHelp[post][2],"Type Banger Num");
post++;
sprintf(TblHelp[post][2],"Type num of banger, then Click ");
post++;
sprintf(TblHelp[post][2],"Banger colonn in front of the mem");
post++;

//fonds rouges init

btitle_help[Hglobal_pos]=1;
btitle_help[Hch_pos]=1;
btitle_help[Hmem_pos]=1;
btitle_help[Hpatch_pos]=1;
btitle_help[Hvideo_pos]=1;
btitle_help[Hhowfader_pos]=1;

btitle_help[Hhowtrichro_pos]=1;
btitle_help[Hhowvideo_pos]=1;
btitle_help[Hhowsequences_pos]=1;


return(0);   
}


int generate_help_file_fr()
{
//reset tableau
for(int l=0;l<1024;l++)
{
 sprintf(TblHelp[l][0],"");
 sprintf(TblHelp[l][1],"");
 sprintf(TblHelp[l][2],""); 
 btitle_help[l]=0;      
}    
    
int post=0;
int Hch_pos=0; int Hmem_pos=0; int Hpatch_pos=0; int Hvideo_pos=0; int Hhowfader_pos=0; int Hhowtrichro_pos=0; int Hhowvideo_pos=0;
int Hhowsequences_pos=0; int Hglobal_pos=0;
// TblHelp[1024][3][24];//512 lignes / 3colonnes /48 caracteres
post++;
sprintf(TblHelp[post][0],"*** COMMANDES GENERALES ***");
post++;
sprintf(TblHelp[post][0],"Ce menu d'aide ");
sprintf(TblHelp[post][1],"[SHIFT][H]");
post++;
sprintf(TblHelp[post][0],"Sauvegarde rapide");
sprintf(TblHelp[post][1],"[CTRL] [S]");
post++;
sprintf(TblHelp[post][0],"Quitter avec sauvegarde");
sprintf(TblHelp[post][1],"[CTRL] [F12]");
post++;
sprintf(TblHelp[post][0],"Quitter sans sauvegarde");
sprintf(TblHelp[post][1],"[SHIFT] [F12]");
post++;
sprintf(TblHelp[post][0],"Snapshot et exctinction fenetres");
sprintf(TblHelp[post][1],"[SHIFT] [PRINT SCREEN]");
post++;
sprintf(TblHelp[post][0],"Rappel du Snapshot des fenetres");
sprintf(TblHelp[post][1],"[CTRL] [PRINT SCREEN]");
post++;
sprintf(TblHelp[post][0],"Circulation dans les fenetres");
sprintf(TblHelp[post][1],"[PGUP] [PGDOWN]");
post++;
sprintf(TblHelp[post][0],"Appel solo des fenetres");
sprintf(TblHelp[post][1],"[CTRL][PGUP] [CTRL][PGDOWN]");
post++;

sprintf(TblHelp[post][0],"Store");
sprintf(TblHelp[post][1],"[F1]");
sprintf(TblHelp[post][2],"Enregistrer les circuits allumes");
post++;
sprintf(TblHelp[post][0],"Modify");
sprintf(TblHelp[post][1],"[F2]");
sprintf(TblHelp[post][2],"Modifier les circuits sélectionnes");
post++;
sprintf(TblHelp[post][0],"Report");
sprintf(TblHelp[post][1],"[F3]");
sprintf(TblHelp[post][2],"Enregistrer circuits et sortie faders");
post++;
sprintf(TblHelp[post][0],"Clear");
sprintf(TblHelp[post][1],"[F4]");
sprintf(TblHelp[post][2],"Nettoyer");
post++;
sprintf(TblHelp[post][0],"Name");
sprintf(TblHelp[post][1],"[F5]");
sprintf(TblHelp[post][2],"Donner un nom");
post++;
sprintf(TblHelp[post][0],"Time");
sprintf(TblHelp[post][1],"[F6]");
sprintf(TblHelp[post][2],"Temps");
post++;
sprintf(TblHelp[post][0],"Trichromy");
sprintf(TblHelp[post][1],"[F7]");
sprintf(TblHelp[post][2],"Trichromie: pour travailler ses cyclos");
post++;
sprintf(TblHelp[post][0],"Video Tracking");
sprintf(TblHelp[post][1],"[F8]");
sprintf(TblHelp[post][2],"Utiliser une webcam comme controleur lumiere");
post++;
sprintf(TblHelp[post][0],"Sequences");
sprintf(TblHelp[post][1],"[F9]");
sprintf(TblHelp[post][2],"Sequentiel");
post++;
sprintf(TblHelp[post][0],"Faders");
sprintf(TblHelp[post][1],"[F10]");
sprintf(TblHelp[post][2],"la barre des 48 faders");
post++;
sprintf(TblHelp[post][0],"Banger");
sprintf(TblHelp[post][1],"[F11]");
sprintf(TblHelp[post][2],"le gestionnaire d'évènements");
post++;
sprintf(TblHelp[post][0],"Blind");
sprintf(TblHelp[post][1],"[Ctrl-F11]");
sprintf(TblHelp[post][2],"Aveugle: le preset à venir dans le sequentiel");
post++;
sprintf(TblHelp[post][0],"Inhiber le midi IN");
sprintf(TblHelp[post][1],"[Shift-F11]");
sprintf(TblHelp[post][2],"");
post++;
post++;
Hch_pos=post;
sprintf(TblHelp[post][0],"*** MANIPULATION DE CIRCUITS ***");
post++;
post++;
sprintf(TblHelp[post][0],"* Selection de circuits");
post++;
sprintf(TblHelp[post][0],"Ajouter a la selection");
sprintf(TblHelp[post][1],"[+]");
sprintf(TblHelp[post][2],"[Num Circ] [+]");
post++;
sprintf(TblHelp[post][0],"Enelver de la selection");
sprintf(TblHelp[post][1],"[-]");
sprintf(TblHelp[post][2],"[Num Circ] [-]");
post++;
sprintf(TblHelp[post][0],"Selection chainee");
sprintf(TblHelp[post][1],"[TAB]");
sprintf(TblHelp[post][2],"[1er Circ] [+] [Dernier Circ] [TAB]");
post++;
sprintf(TblHelp[post][0],"Selectionner tous les circuits allumes");
sprintf(TblHelp[post][1],"[Y]");
post++;
sprintf(TblHelp[post][0],"Selection inversee");
sprintf(TblHelp[post][1],"[U]");
post++;
sprintf(TblHelp[post][0],"Tout deselectionner");
sprintf(TblHelp[post][1],"[ESC]");
post++;
sprintf(TblHelp[post][0],"Selectionner le precedent");
sprintf(TblHelp[post][1],"[ARROW LEFT]");
post++;
sprintf(TblHelp[post][0],"Selectionner le suivant");
sprintf(TblHelp[post][1],"[ARROW RIGHT]");
post++;
post++;
sprintf(TblHelp[post][0],"* Donner un niveau aux circuits selectionnes");
post++;
sprintf(TblHelp[post][0],"FULL");
sprintf(TblHelp[post][1],"[I]");
post++;
sprintf(TblHelp[post][0],"ZERO");
sprintf(TblHelp[post][1],"[O]");
post++;
sprintf(TblHelp[post][0],"Niveau specifique");
sprintf(TblHelp[post][1],"[ENTER]");
sprintf(TblHelp[post][2],"[niveau] [ENTER]");
post++;
sprintf(TblHelp[post][0],"Plus %");
sprintf(TblHelp[post][1],"[fleche haut]");
post++;
sprintf(TblHelp[post][0],"Moins %");
sprintf(TblHelp[post][1],"[fleche bas]");
post++;
post++;
sprintf(TblHelp[post][0],"* Check Channel a Full");
post++;
sprintf(TblHelp[post][0],"Precedent a FULL");
sprintf(TblHelp[post][1],"[CTRL] [fleche gauche]");
post++;
sprintf(TblHelp[post][0],"Suivant a FULL");
sprintf(TblHelp[post][1],"[CTRL] [fleche droite]");
post++;
post++;
Hmem_pos=post;
sprintf(TblHelp[post][0],"*** MEMOIRES ET SEQUENTIEL [F9] ***");
post++;
post++;
sprintf(TblHelp[post][0],"* Enregistrer ou detruire des memoires");
post++;
sprintf(TblHelp[post][0],"Creer ou Re-enregistrer par num.");
sprintf(TblHelp[post][1],"[SHIFT] [F1]");
sprintf(TblHelp[post][2],"[num. Mem] [SHIFT] [F1]");
post++;
sprintf(TblHelp[post][0],"Sortir du sequentiel");
sprintf(TblHelp[post][1],"[SHIFT] [DEL]");
sprintf(TblHelp[post][2],"[num. Mem] [SHIFT] [DEL]");
post++;
sprintf(TblHelp[post][0],"Re-enregistrer (scene ou preset)");
sprintf(TblHelp[post][1],"[CTRL] [F1]");
post++;
sprintf(TblHelp[post][0],"Rappeler l'etat avant modification");
sprintf(TblHelp[post][1],"[CTRL] [Z]");
post++;
sprintf(TblHelp[post][0],"Remettre dans le sequentiel");
sprintf(TblHelp[post][1],"[SHIFT] [Z]");
post++;
post++;
sprintf(TblHelp[post][0],"* Navigation rapide dans les memoires");
post++;
sprintf(TblHelp[post][0],"Mem precedente sur scene");
sprintf(TblHelp[post][1],"[CTRL] [W]");
post++;
sprintf(TblHelp[post][0],"Mem suivante sur scene");
sprintf(TblHelp[post][1],"[CTRL] [X]");
post++;
sprintf(TblHelp[post][0],"Mem precedente en preset");
sprintf(TblHelp[post][1],"[SHIFT] [W]");
post++;
sprintf(TblHelp[post][0],"Mem suivante en preset");
sprintf(TblHelp[post][1],"[SHIFT] [X]");
post++;
post++;
sprintf(TblHelp[post][0],"* Crossfade");
post++;
sprintf(TblHelp[post][0],"GO / PAUSE");
sprintf(TblHelp[post][1],"[SPACE]");
post++;
sprintf(TblHelp[post][0],"GO BACK");
sprintf(TblHelp[post][1],"[CTRL] [SPACE]");
post++;
sprintf(TblHelp[post][0],"DOUBLE GO");
sprintf(TblHelp[post][1],"[SHIFT] [SPACE]");
post++;
post++;
post++;
Hpatch_pos=post;
sprintf(TblHelp[post][0],"*** PATCH  ***");
sprintf(TblHelp[post][1],"[SHIFT] [P]");
post++;
post++;
sprintf(TblHelp[post][0],"* Selection des gradateurs (Dimmers)");
sprintf(TblHelp[post][2],"Memes commandes que les circuits +[SHIFT]");
post++;
sprintf(TblHelp[post][0],"Ajouter a la selection");
sprintf(TblHelp[post][1],"[SHIFT] [+]");
sprintf(TblHelp[post][2],"[Num Dim] [SHIFT] [+]");
post++;
sprintf(TblHelp[post][0],"Retirer de la selection");
sprintf(TblHelp[post][1],"[SHIFT] [-]");
sprintf(TblHelp[post][2],"[Num Dim] [SHIFT] [-]");
post++;
sprintf(TblHelp[post][0],"Selection chainee");
sprintf(TblHelp[post][1],"[SHIFT] [TAB]");
sprintf(TblHelp[post][2],"[1er Dim][SHIFT][+] [Dernier Dim][SHIFT][TAB]");
post++;
sprintf(TblHelp[post][0],"Selectionner tous ");
sprintf(TblHelp[post][1],"[SHIFT] [Y]");
post++;
sprintf(TblHelp[post][0],"Selection inversee ");
sprintf(TblHelp[post][1],"[SHIFT] [U]");
post++;
sprintf(TblHelp[post][0],"Deselectionner tous ");
sprintf(TblHelp[post][1],"[SHIFT] [ESC]");
post++;
post++;
sprintf(TblHelp[post][0],"* Affecter un gradateur a un circuit");
post++;
sprintf(TblHelp[post][0],"Au dernier circuit selectionne ");
sprintf(TblHelp[post][1],"[SHIFT] [ENTER]");
sprintf(TblHelp[post][2],"[Num circ][+][Num Dim][SHIFT][+][SHIFT][ENTER]");
post++;
sprintf(TblHelp[post][2],"                                         ou ");
post++;
sprintf(TblHelp[post][2],"[Num Dim][SHIFT][+][Num circ][+][SHIFT][ENTER]");
post++;
sprintf(TblHelp[post][0],"Voir les gradateurs controlles par un circuit");
post++;
sprintf(TblHelp[post][0],"Selection des circuits par");
post++;
sprintf(TblHelp[post][2],"[FLECHE GAUCHE] et [FLECHE DROITE]");
post++;
sprintf(TblHelp[post][0],"CHECK GRADA 75%( bypass le patch )");
post++;
sprintf(TblHelp[post][2],"[SHIFT][FLECHE GAUCHE]-[SHIFT][FLECHE DROITE]");
post++;
post++;
post++;
Hvideo_pos=post;
sprintf(TblHelp[post][0],"*** TRACKING VIDEO ***");
sprintf(TblHelp[post][1],"[F8]");
post++;
sprintf(TblHelp[post][0],"Presets 1 a 6");
sprintf(TblHelp[post][1],"[W][X][C][V][B][N]");
post++;
sprintf(TblHelp[post][0],"ROI 1 a 6");
sprintf(TblHelp[post][1],"[A][Z][E][R][T][Y]");
post++;
sprintf(TblHelp[post][0],"ROI 7 a 12");
sprintf(TblHelp[post][1],"[Q][S][D][F][G][H]");
post++;
post++;
post++;
Hhowfader_pos=post;
sprintf(TblHelp[post][0],"*** PETIT 'HOW TO' EXHAUSTIF ***");
post++;
post++;
sprintf(TblHelp[post][0],"* FADERS et DOCKS");
post++;
sprintf(TblHelp[post][0],"Enregistrer des circuits dans un dock");
post++;
sprintf(TblHelp[post][2],"Allumer les circuits, sur scene ou en blind");
post++;
sprintf(TblHelp[post][2],"Taper [F1] ou clicker [STORE]");
post++;
sprintf(TblHelp[post][2],"Clicker le dock ou les enregistrer");
post++;
sprintf(TblHelp[post][0],"Affecter une memoire a un dock");
post++;
sprintf(TblHelp[post][2],"Taper le numero de la memoire");
post++;
sprintf(TblHelp[post][2],"Taper [F1] ou clicker [STORE]");
post++;
sprintf(TblHelp[post][2],"Clicker le dock ou l'enregistrer");
post++;
sprintf(TblHelp[post][0],"Donner un descriptif a un dock");
post++;
sprintf(TblHelp[post][2],"Clicker [NAME] ou taper [F5], taper le texte");
post++;
sprintf(TblHelp[post][2],"Clicker le dock ou l'enregistrer");
post++;
sprintf(TblHelp[post][0],"Affecter un temps dans un dock");
post++;
sprintf(TblHelp[post][2],"Clicker [TIME] ou taper [F4], choisir le temps");
post++;
sprintf(TblHelp[post][2],"Choisir l'operateur [IN][OUT]...clicker [AFFECT]");
post++;
sprintf(TblHelp[post][2],"Clicker le dock auquel attribuer ces temps");
post++;
sprintf(TblHelp[post][0],"Affecter du DMX IN a un dock");
post++;
sprintf(TblHelp[post][2],"Clicker [ART-NET>dock] ou [DMX-IN>dock]");
post++;
sprintf(TblHelp[post][2],"Clicker the dock auquel l'affecter");
post++;
sprintf(TblHelp[post][0],"Affecter un preset de la trichro a un dock");
post++;
sprintf(TblHelp[post][2],"Selectionner le preset dans la Trichromie");
post++;
sprintf(TblHelp[post][2],"Clicker [AFFECT TO DOCK]");
post++;
sprintf(TblHelp[post][2],"Clicker le dock auquel l'attribuer");
post++;
sprintf(TblHelp[post][0],"Affecter la sortie du Tracking video a un dock");
post++;
sprintf(TblHelp[post][2],"Clicker [AFFECT TO DOCK]");
post++;
sprintf(TblHelp[post][2],"Clicker le dock auquel l'attribuer");
post++;
sprintf(TblHelp[post][0],"Nettoyer un dock");
post++;
sprintf(TblHelp[post][2],"Clicker [CLEAR] ou taper [F4]");
post++;
sprintf(TblHelp[post][2],"Clicker le dock a nettoyer");
post++;
sprintf(TblHelp[post][0],"Nettoyer completement un fader");
post++;
sprintf(TblHelp[post][2],"Clicker [CLEAR] ou taper [F4]");
post++;
sprintf(TblHelp[post][2],"Clicker le fader nettoyer");
post++;
sprintf(TblHelp[post][0],"Voir le contenu d'un dock");
post++;
sprintf(TblHelp[post][2],"Clicker [VIEW]");
post++;
sprintf(TblHelp[post][2],"Passer à la souris au dessus du dock");
post++;
sprintf(TblHelp[post][0],"LOCKer des faders ( grouper en une seule commande)");
post++;
sprintf(TblHelp[post][2],"Clicker [LOCK]");
post++;
sprintf(TblHelp[post][2],"Le niveau est pris alors comme niveau locke");
post++;
sprintf(TblHelp[post][2],"A Fader a FULL lors du lockage devient maitre ");
post++;
sprintf(TblHelp[post][0],"REPORT: fusionner tous les faders dans un seul");
post++;
sprintf(TblHelp[post][2],"Clicker [REPORT]");
post++;
sprintf(TblHelp[post][2],"Clicker le Fader devant tout recevoir:");
post++;
sprintf(TblHelp[post][2],"Tous les Faders allumes y sont enregistres ");
post++;
post++;
Hhowtrichro_pos=post;
sprintf(TblHelp[post][0],"* TRICHROMIE");
post++;
post++;
sprintf(TblHelp[post][0],"Affecter des circuits a une couleur");
post++;
sprintf(TblHelp[post][2],"Selectionner les circuits");
post++;
sprintf(TblHelp[post][2],"Taper [F1] ou clicker [STORE]");
post++;
sprintf(TblHelp[post][2],"Clicker la couleur ou les affecter");
post++;
sprintf(TblHelp[post][0],"Voir les circuits d'une couleur");
post++;
sprintf(TblHelp[post][2],"Clicker [VIEW]");
post++;
sprintf(TblHelp[post][2],"Passer au dessus de la couleur avec la souris");
post++;
sprintf(TblHelp[post][0],"Affecter un Preset Trichromie a un dock");
post++;
sprintf(TblHelp[post][2],"Clicker [AFFECT TO DOCK]");
post++;
sprintf(TblHelp[post][2],"Clicker le dock ou l'affecter");
post++;
post++;
Hhowvideo_pos=post;
sprintf(TblHelp[post][0],"* TRACKING VIDEO ");
post++;
sprintf(TblHelp[post][0],"Affecter des circuits a une ROI");
post++;
sprintf(TblHelp[post][2],"Selectionner les circuits");
post++;
sprintf(TblHelp[post][2],"Taper [F1] ou clicker [STORE]");
post++;
sprintf(TblHelp[post][2],"Clicker la ROI à laquelle les affecter");
post++;
sprintf(TblHelp[post][0],"Voir le contenu d'une ROI");
post++;
sprintf(TblHelp[post][2],"Clicker [VIEW]");
post++;
sprintf(TblHelp[post][2],"Passer la souris au dessus de la pin");
post++;
sprintf(TblHelp[post][0],"Affecter un Tracking Preset a un dock");
post++;
sprintf(TblHelp[post][2],"Clicker [AFFECT TO DOCK]");
post++;
sprintf(TblHelp[post][2],"Clicker le dock desire");
post++;
post++;
Hhowsequences_pos=post;


sprintf(TblHelp[post][0],"* SEQUENTIEL");
post++;
sprintf(TblHelp[post][0],"Creer une memoire ou re-enregistrer");
post++;
sprintf(TblHelp[post][2],"Creer l etat lumineux sur scene ou en blind");
post++;
sprintf(TblHelp[post][2],"Taper le num. de memoire, clicker [Create mem]");
post++;
sprintf(TblHelp[post][2],"                        ou taper  [SHIFT] [F1]");
post++;
sprintf(TblHelp[post][2],"Appeler une memoire");
post++;
sprintf(TblHelp[post][0],"Taper le num de memoire");
post++;
sprintf(TblHelp[post][2],"Clicker la case Mem du stage ou du preset");
post++;
sprintf(TblHelp[post][2],"(Fonctionne aussi en crossfade sur le preset)");
post++;
sprintf(TblHelp[post][2],"Re-eneregistrement rapide en stage ou preset");
post++;
sprintf(TblHelp[post][0],"Taper [F1] ou clicker [STORE]");
post++;
sprintf(TblHelp[post][2],"Clicker la mem sur stage ou en preset");
post++;
sprintf(TblHelp[post][0],"Oujuste taper [CTRL][F1]");
post++;
sprintf(TblHelp[post][0],"Affecter les temps a une memoire");
post++;
sprintf(TblHelp[post][2],"Utiliser Time [F5] ");
post++;
sprintf(TblHelp[post][2],"Choisir [IN] [OUT]... et enclencher [AFFECT]");
post++;
sprintf(TblHelp[post][2],"Clicker la case de la memoire memoire");
post++;
sprintf(TblHelp[post][2],"OU ( seulement sur scene ou en preset ) ");
post++;
sprintf(TblHelp[post][2],"Taper le temps: [ 5 ][ . ] est 5 secondes ");
post++;
sprintf(TblHelp[post][2],"[ 1 ][ . ][ . ] [ 1 ][ 0 ] [ . ] est 1 min 10 sec");
post++;
sprintf(TblHelp[post][2],"[ 4 ][ . ] [ 5 ] est 4 sec 5 1/10e");
post++;
sprintf(TblHelp[post][2],"Clicker la pin de temps ou entrer ce temps");
sprintf(TblHelp[post][0],"Enregistrer la sortie des masters dans une mem");
post++;
sprintf(TblHelp[post][2],"utiliser [REPORT] [F3] au lieu de [F1]");
post++;
sprintf(TblHelp[post][0],"Modifier");
post++;
sprintf(TblHelp[post][2],"selectionner les circuits, leur donner une valeur");
post++;
sprintf(TblHelp[post][2],"utiliser [MODIFY] [F2] au lieu de [F1]");
post++;
sprintf(TblHelp[post][0],"Donner une description a une memoire");
post++;
sprintf(TblHelp[post][2],"clicker [NAME] ou taper [F5]");
post++;
sprintf(TblHelp[post][2],"taper le descriptif");
post++;
sprintf(TblHelp[post][2],"clicker l'espace de description de la memoire");
post++;
sprintf(TblHelp[post][0],"Linker des memoires ( autogo)");
post++;
sprintf(TblHelp[post][2],"[Link] doit etre active");
post++;
sprintf(TblHelp[post][2],"Clicker la pin de Link en face de la mem");
post++;
sprintf(TblHelp[post][0],"Affecter un Banger a une memoire");
post++;
sprintf(TblHelp[post][2],"[Banger] doit etre active");
post++;
sprintf(TblHelp[post][2],"Taper le numero de Banger ");
post++;
sprintf(TblHelp[post][2],"Clicker la case Banger de la memoire");
post++;



//fonds rouges init

btitle_help[Hglobal_pos]=1;
btitle_help[Hch_pos]=1;
btitle_help[Hmem_pos]=1;
btitle_help[Hpatch_pos]=1;
btitle_help[Hvideo_pos]=1;
btitle_help[Hhowfader_pos]=1;

btitle_help[Hhowtrichro_pos]=1;
btitle_help[Hhowvideo_pos]=1;
btitle_help[Hhowsequences_pos]=1;



return(0);   
}
