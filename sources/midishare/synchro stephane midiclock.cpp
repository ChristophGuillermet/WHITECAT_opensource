/*====================== A MIDI SHARE TOOL  (© GRAME 92) =====================NAME      SyncClock -- a very simple MidiShare MPW toolSYNOPSIS      SyncClock [-fo <format>] [-hh <hour>] [-mn <minutes>] [-ss <seconds>] 	  	User type <q/Q> to quitDESCRIPTION	"SyncClock" open a MidiShare session, send Midi time codes, and 	then close the MidiShare session when user type <q>===============================================================================*/ #include <String.h>#include <StdLib.h>#include <Stdio.h>//#include <siow.h>#include <MidiShare.h>#define nil 	0#define true	1#define false	0int			speed = 1000;int			phase = 0;int			format = 25;short		ref = -1;MidiEvPtr	myTask = 0;TSyncInfo	info, dummy;long		delay = 10;long		dur = 0x7FFFFFFF;int			gRunning = 0;long		gOffset = 0;//_______________________________________________________________________typedef struct smpte{	Byte	hh;	Byte	mn;	Byte	ss;	Byte	qf;} smpte;long smpte2qf(long fo, smpte t){	return ((t.hh * 60 + t.mn) * 60 + t.ss) * (fo << 2) + t.qf;}smpte qf2smpte(long fo, long qf){	smpte  	t;	long	n;		fo = fo << 2;		qf = qf + gOffset * fo;		t.qf = qf % fo;	n = qf / fo;		//n = n + (gOffset * 60); //		t.ss = n % 60;	n = n / 60;	t.mn = n % 60;	t.hh = n / 60;		return t;}long qf2ms(long fo, long qf){	return (qf * speed + fo + fo) / (fo << 2);}//_______________________________________________________________________MidiEvPtr MakeQuarterFrame (short port, short field0, short field1){	MidiEvPtr	e;		if (e = MidiNewEv(typeQuarterFrame)) {		e->info.data[0] = field0;		e->info.data[1] = field1;		Port(e) = port;	}	return e;}//_______________________________________________________________________void SendDblFrame (short r, short port, short fo, long * pd, long * pqf){	smpte		t;	long		d1;	short		frmt;	long		offset, qf;		qf = *pqf;	t = qf2smpte(fo, qf);		d1 = qf2ms(fo, qf);	offset = *pd - d1;	switch (fo) {		case 24 : frmt = 0; break;		case 25 : frmt = 1; break;		case 29 : frmt = 2; break;		case 30 : frmt = 3; break;	}	 //frames	MidiSendAt(r, MakeQuarterFrame(port, 0, (t.qf >> 2) & 15), *pd);	MidiSendAt(r, MakeQuarterFrame(port, 1, t.qf >> 6), offset + qf2ms(fo, ++qf)); //seconds	MidiSendAt(r, MakeQuarterFrame(port, 2, t.ss & 15), offset + qf2ms(fo, ++qf));	MidiSendAt(r, MakeQuarterFrame(port, 3, t.ss >> 4), offset + qf2ms(fo, ++qf)); //minutes	MidiSendAt(r, MakeQuarterFrame(port, 4, t.mn & 15), offset + qf2ms(fo, ++qf));	MidiSendAt(r, MakeQuarterFrame(port, 5, t.mn >> 4), offset + qf2ms(fo, ++qf)); //hours	MidiSendAt(r, MakeQuarterFrame(port, 6, t.hh & 15), offset + qf2ms(fo, ++qf));	MidiSendAt(r, MakeQuarterFrame(port, 7, (t.hh >> 4) | (frmt << 1)), offset + qf2ms(fo, ++qf));	 //updates	*pd = offset + qf2ms(fo, ++qf); 	*pqf = qf;}//_______________________________________________________________________static void synctask(long date, short r, long fo, long qf, long n){	long d;	if (n > 0) {		d = date + delay;		SendDblFrame(r, 0, fo, &d, &qf);		myTask = MidiTask(synctask, d-delay, r, fo, qf, n-1);	} else {		myTask = 0;	}}void startTask(){	long offset, d;		MidiForgetTask(&myTask);		MidiGetSyncInfo(&info); 	if (info.syncLocked) {		offset = info.syncOffset;		format = info.syncFormat;	} else {		offset = 0;	}		gRunning = 1;	d = ((MidiGetTime() + offset) / speed + 1) * speed - offset + phase;	// calcul une frontière de seconde	synctask(d - delay, ref, format, 0, dur);								// lance la tâche avec une anticipation de 10}void stopStart(){	gRunning = 0;	MidiForgetTask(&myTask);}char * ms2smpte(long date, int format, char * s){	long hh, mn, ss, fr;		ss = date / 1000;	mn = ss / 60; ss %= 60;	hh = mn / 60; mn %= 60;	fr = date % 1000 * format / 1000;	sprintf(s, " %02d : %02d : %02d . %02d ", hh, mn, ss, fr);	return s;}void printinfo(){	char sd[20];		MidiGetSyncInfo(&info); 	printf("\nSYNC INFO AT DATE : %d (%s)\n", info.time, ms2smpte(info.time + info.syncOffset, info.syncFormat, sd));	printf("  reenter count   : %d\n", info.reenter);	printf("  mode : %5d, locked : %1d, format : %2d, port : %3d\n", 				info.syncMode, info.syncLocked, info.syncFormat, info.syncPort);	printf("  sync start at : %10d (%s)\n", info.syncStart, ms2smpte(info.syncStart + info.syncOffset, info.syncFormat, sd));	printf("  sync stop  at : %10d (%s)\n", info.syncStop, ms2smpte(info.syncStop + info.syncOffset, info.syncFormat, sd));	printf("  sync offset : %10d, sync speed : %10d, sync breaks : %10d\n",				info.syncOffset, info.syncSpeed, info.syncBreaks);}	//_______________________________________________________________________static void ApplAlarm( short r, long code ){	if ( code == MIDISyncStart ) startTask();}//_______________________________________________________________________static void ReceiveAlarm(short ref){	MidiEvPtr ev;		while ((ev = MidiGetEv(ref))) {			switch (EvType(ev)) {					case typeNote:			case typeKeyOn:				if (Pitch(ev) == 60 && !gRunning) {					startTask();				}				break;							default:				break;		}			MidiFreeEv(ev);	}}//_______________________________________________________________________int main(int argc, char* argv[]){	char cmd[512];	char val[512];		ref = MidiOpen("Synchronizer");			// open a MidiShare session	MidiConnect(ref, 0, true);				// connect to physical Midi outputs	MidiConnect(0, ref, true);				// connect to physical Midi input	MidiSetSyncMode(MIDISyncExternal | MIDISyncAnyPort);	MidiSetApplAlarm(ref, ApplAlarm);	MidiSetRcvAlarm(ref, ReceiveAlarm);	//startTask();		long hrs,min,sec;		printf("Taper 'q' pour quitter\n");	printf("Taper 'p' pour lancer la synchro\n");	printf("Taper 's' pour arreter la synchro\n");	printf("Taper 'offset = hh:mm:ss' pour changer la valeur de l'offset\n");		while (gets(cmd)) {		printf ("cmd : %s\n", cmd);		if (cmd[0] == 'q') {			MidiClose(ref);			return  0;		} else if (cmd[0] == 'i') {			printinfo();		} else if (sscanf(cmd, "format %d", &format) == 1) {			startTask();		} else if (sscanf(cmd, "speed %d", &speed) == 1) {			;		} else if (sscanf(cmd, "phase %d", &phase) == 1) {			startTask();		} else if (sscanf(cmd, "dur %d", &dur) == 1) {			startTask();		} else if (cmd[0] == 's') {			if (gRunning) {				stopStart();			}		} else if (cmd[0] == 'p') {			startTask();		} else if (sscanf(cmd, "offset %s", val) == 1) {			sscanf(cmd, "offset =%d:%d:%d", &hrs, &min, &sec);			gOffset = (hrs * 3600 + min * 60 + sec) + 1;			printf("offset %ld sec \n", gOffset);			if (gRunning) {				stopStart();			}		}	}		return 0;}